/* eslint-disable no-return-assign, no-sequences */
'use strict';
Reflect.defineProperty(exports, '__esModule', { value: true });

exports.default = function get(object, prop) {
  const stringprop = prop.toString();
  let t = stringprop;
  // DebugKey: console.log('retrieving key: ', t, new Error)
  if (t[0] === '$') {
    // eslint-disable-next-line no-cond-assign
    if (t = this.traps.get(stringprop.replace(/[_-]|sync/g, ''))) return t.value(object, prop, stringprop);
    for (const _trap of this.traps.values()) {
      if (_trap.condition({ prop, stringprop })) return _trap.value(object, prop, stringprop);
    }
    // eslint-disable-next-line no-cond-assign
  } else if (t && (t = this.traps.__internal.find(trap => trap.condition({ prop, stringprop })))) {
    return t.value(object, prop, stringprop);
  }
  const new_parts = [...this.parts, prop.toString()];

  if (!this.use_cache) {
    return new this.constructor(this.base,
      this._properties.reduce((obj, p) => (obj[p] = this[p], obj), {}), new_parts);
  }
  const id = [this.base, ...new_parts].join(process.pid);
  return this.constructor.cache[id] || (this.constructor.cache[id] = new this.constructor(this.base,
    this._properties.reduce((obj, p) => (obj[p] = this[p], obj), {}), new_parts));
};
